# 재고관리 (Inventory Management)

## 기능
- SKU 추가/수정/조회
- 입/출고

## 재고를 어떻게 테이블로 구현할것인가?

크게 3가지방법이 머리에 떠올랐습니다.

### 재고 하나당 테이블상의 행(튜플) 하나 전략 (채택)
데이터베이스에 재고를 담당하는 테이블 Inventory 를 만들고, 입고를 하면 행을 추가하고, 출고를 하면 행을 삭제합니다.
예를 들어 재고가 5개 입고 되면 테이블의 행의 갯수는 5개가 증가하고, 5개가 출고되면 행의 갯수는 5개가 감소합니다.

- 장점
    - Concurrency 문제가 없습니다.
    - 각각의 입/출고 마다 사유를 작성할수 있습니다. (신규/배송/반품/하자)
- 단점
    - 입/출고 해야 할 재고의 갯수가 크다면 insert/delete 부하가 있을수 있습니다. 따라서 한번에 입/출고할 양의 제한을 두거나 비동기 처리 구현이 필요할수도 있습니다.


### 카운트 속성 사용
SKU 테이블에 재고의 갯수를 나타내는 컬럼을 통해 관리합니다. 예를 들어 기본키가 1인 SKU의 재고를 2개 입고하면, 해당 행의 컬럼속성(예, count: BigINT)을 증가시킵니다.

- 장점
    - 구현이 상대적으로 간편합니다.

- 단점
    - 각각의 입/출고 마다 사유를 작성하기 힘듭니다. 사유를 기록할 로그 테이블을 생성하면 좋을것 같습니다.
    - Concurrency 문제가 있을수 있습니다. 입/출고시 SERIALIIZABLE 트랜잭션 격리 전략이 필요할수 있습니다.

### 입/출고 행위 하나당 테이블상의 행(튜플) 하나 전략
데이터베이스에 재고를 담당하는 테이블 Inventory 를 만들고, 입/출고를 진행시 행을 하나 추가합니다.
추가되는 행에는 입/출고 여부, 입/출고 한 재고의 갯수등의 정보를 가지고 있습니다.
특정 SKU의 재고의 갯수를 구하기 위해서는 SKU의 입/출고 기록을 Inventory에서 모두 조회하여 입/출고 한 재고의 갯수를 집계하면 됩니다.

- 장점
  - 갯수 정보 뿐만아니라 각각의 입/출고 행위 마다 사유를 작성할수 있습니다. (신규/배송/반품/하자)

- 단점
  - Concurrency 문제가 있습니다. 입/출고시 SERIALIIZABLE 트랜잭션 격리 전략이 필요할수 있습니다.
  - 재고의 갯수를 조회할때마다 집계할 행이 많다면 데이터베이스 부하가 발생할수 있습니다. 이 문제는 테이블에 인덱스를 도입하거나, 주기적인 배치를 통해 inventory 테이블의 내용을 다른 테이블에 백업한후 하나의 행으로 압축해서 부하를 줄이는 방법이 있습니다.
